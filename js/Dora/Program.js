var __Program=''
+'// Package martini is a powerful package for quickly writing modular web applications/services in Golang.\n'
+'//\n'
+'// For a full guide visit http://github.com/go-martini/martini\n'
+'//\n'
+'//  package main\n'
+'//\n'
+'//  import "github.com/go-martini/martini"\n'
+'//\n'
+'//  func main() {\n'
+'//    m := martini.Classic()\n'
+'//\n'
+'//    m.Get("/", func() string {\n'
+'//      return "Hello world!"\n'
+'//    })\n'
+'//\n'
+'//    m.Run()\n'
+'//  }\n'
+'package martini\n'
+'\n'
+'import (\n'
+'	"log"\n'
+'	"net/http"\n'
+'	"os"\n'
+'	"reflect"\n'
+'\n'
+'	"github.com/codegangsta/inject"\n'
+')\n'
+'\n'
+'// Martini represents the top level web application. inject.Injector methods can be invoked to map services on a global level.\n'
+'type Martini struct {\n'
+'	inject.Injector\n'
+'	handlers []Handler\n'
+'	action   Handler\n'
+'	logger   *log.Logger\n'
+'}\n'
+'\n'
+'// New creates a bare bones Martini instance. Use this method if you want to have full control over the middleware that is used.\n'
+'func New() *Martini {\n'
+'	m := &Martini{Injector: inject.New(), action: func() {}, logger: log.New(os.Stdout, "[martini] ", 0)}\n'
+'	m.Map(m.logger)\n'
+'	m.Map(defaultReturnHandler())\n'
+'	return m\n'
+'}\n'
+'\n'
+'// Handlers sets the entire middleware stack with the given Handlers. This will clear any current middleware handlers.\n'
+'// Will panic if any of the handlers is not a callable function\n'
+'func (m *Martini) Handlers(handlers ...Handler) {\n'
+'	m.handlers = make([]Handler, 0)\n'
+'	for _, handler := range handlers {\n'
+'		m.Use(handler)\n'
+'	}\n'
+'}\n'
+'\n'
+'// Action sets the handler that will be called after all the middleware has been invoked. This is set to martini.Router in a martini.Classic().\n'
+'func (m *Martini) Action(handler Handler) {\n'
+'	validateHandler(handler)\n'
+'	m.action = handler\n'
+'}\n'
+'\n'
+'// Logger sets the logger\n'
+'func (m *Martini) Logger(logger *log.Logger) {\n'
+'	m.logger = logger\n'
+'	m.Map(m.logger)\n'
+'}\n'
+'\n'
+'// Use adds a middleware Handler to the stack. Will panic if the handler is not a callable func. Middleware Handlers are invoked in the order that they are added.\n'
+'func (m *Martini) Use(handler Handler) {\n'
+'	validateHandler(handler)\n'
+'\n'
+'	m.handlers = append(m.handlers, handler)\n'
+'}\n'
+'\n'
+'// ServeHTTP is the HTTP Entry point for a Martini instance. Useful if you want to control your own HTTP server.\n'
+'func (m *Martini) ServeHTTP(res http.ResponseWriter, req *http.Request) {\n'
+'	m.createContext(res, req).run()\n'
+'}\n'
+'\n'
+'// Run the http server on a given host and port.\n'
+'func (m *Martini) RunOnAddr(addr string) {\n'
+'	// TODO: Should probably be implemented using a new instance of http.Server in place of\n'
+'	// calling http.ListenAndServer directly, so that it could be stored in the martini struct for later use.\n'
+'	// This would also allow to improve testing when a custom host and port are passed.\n'
+'\n'
+'	logger := m.Injector.Get(reflect.TypeOf(m.logger)).Interface().(*log.Logger)\n'
+'	logger.Printf("listening on %s (%s)\n", addr, Env)\n'
+'	logger.Fatalln(http.ListenAndServe(addr, m))\n'
+'}\n'
+'\n'
+'// Run the http server. Listening on os.GetEnv("PORT") or 3000 by default.\n'
+'func (m *Martini) Run() {\n'
+'	port := os.Getenv("PORT")\n'
+'	if len(port) == 0 {\n'
+'		port = "3000"\n'
+'	}\n'
+'\n'
+'	host := os.Getenv("HOST")\n'
+'\n'
+'	m.RunOnAddr(host + ":" + port)\n'
+'}\n'
+'\n'
+'func (m *Martini) createContext(res http.ResponseWriter, req *http.Request) *context {\n'
+'	c := &context{inject.New(), m.handlers, m.action, NewResponseWriter(res), 0}\n'
+'	c.SetParent(m)\n'
+'	c.MapTo(c, (*Context)(nil))\n'
+'	c.MapTo(c.rw, (*http.ResponseWriter)(nil))\n'
+'	c.Map(req)\n'
+'	return c\n'
+'}\n'
+'\n'
+'// ClassicMartini represents a Martini with some reasonable defaults. Embeds the router functions for convenience.\n'
+'type ClassicMartini struct {\n'
+'	*Martini\n'
+'	Router\n'
+'}\n'
+'\n'
+'// Classic creates a classic Martini with some basic default middleware - martini.Logger, martini.Recovery and martini.Static.\n'
+'// Classic also maps martini.Routes as a service.\n'
+'func Classic() *ClassicMartini {\n'
+'	r := NewRouter()\n'
+'	m := New()\n'
+'	m.Use(Logger())\n'
+'	m.Use(Recovery())\n'
+'	m.Use(Static("public"))\n'
+'	m.MapTo(r, (*Routes)(nil))\n'
+'	m.Action(r.Handle)\n'
+'	return &ClassicMartini{m, r}\n'
+'}\n'
+'\n'
+'// Handler can be any callable function. Martini attempts to inject services into the handler\'s argument list.\n'
+'// Martini will panic if an argument could not be fullfilled via dependency injection.\n'
+'type Handler interface{}\n'
+'\n'
+'func validateHandler(handler Handler) {\n'
+'	if reflect.TypeOf(handler).Kind() != reflect.Func {\n'
+'		panic("martini handler must be a callable func")\n'
+'	}\n'
+'}\n'
+'\n'
+'// Context represents a request context. Services can be mapped on the request level from this interface.\n'
+'type Context interface {\n'
+'	inject.Injector\n'
+'	// Next is an optional function that Middleware Handlers can call to yield the until after\n'
+'	// the other Handlers have been executed. This works really well for any operations that must\n'
+'	// happen after an http request\n'
+'	Next()\n'
+'	// Written returns whether or not the response for this context has been written.\n'
+'	Written() bool\n'
+'}\n'
+'\n'
+'type context struct {\n'
+'	inject.Injector\n'
+'	handlers []Handler\n'
+'	action   Handler\n'
+'	rw       ResponseWriter\n'
+'	index    int\n'
+'}\n'
+'\n'
+'func (c *context) handler() Handler {\n'
+'	if c.index < len(c.handlers) {\n'
+'		return c.handlers[c.index]\n'
+'	}\n'
+'	if c.index == len(c.handlers) {\n'
+'		return c.action\n'
+'	}\n'
+'	panic("invalid index for context handler")\n'
+'}\n'
+'\n'
+'func (c *context) Next() {\n'
+'	c.index += 1\n'
+'	c.run()\n'
+'}\n'
+'\n'
+'func (c *context) Written() bool {\n'
+'	return c.rw.Written()\n'
+'}\n'
+'\n'
+'func (c *context) run() {\n'
+'	for c.index <= len(c.handlers) {\n'
+'		_, err := c.Invoke(c.handler())\n'
+'		if err != nil {\n'
+'			panic(err)\n'
+'		}\n'
+'		c.index += 1\n'
+'\n'
+'		if c.Written() {\n'
+'			return\n'
+'		}\n'
+'	}\n'
+'}\n'
+'\n\n                       END_';